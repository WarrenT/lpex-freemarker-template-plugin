package com.freemarker.lpex.utils;import java.io.File;import java.io.FileInputStream;import java.io.FileNotFoundException;import java.io.FileOutputStream;import java.io.IOException;import java.nio.channels.FileChannel;import java.util.Calendar;import java.util.Date;import java.util.Properties;import com.freemarker.lpex.preferences.Preferences;/** * Helper class to synchronize server sided team templates with a local template * directory. The synchronisation takes place every 12 hours, when RDi is * started again or when a source member is loaded into the Lpex-Editor. *  * @author Thomas Raddatz */public final class TemplateDirectorySyncHelper {    /**     * The instance of this Singleton class.     */    private static TemplateDirectorySyncHelper instance;    private static final int FAT_PRECISION = 2000;    private static final long DEFAULT_COPY_BUFFER_SIZE = 16 * 1024 * 1024; // 16    private static final long SYNC_INTERVAL_IN_HOURS = 12;    private static String teamTemplatesDirectoryName;    private static boolean syncTemplatesEnabled;    private static boolean syncParserAssociationsEnabled;    /**     * Private constructor to ensure the Singleton pattern.     */    private TemplateDirectorySyncHelper() {    }    /**     * Thread-safe method that returns the instance of this Singleton class.     */    public synchronized static TemplateDirectorySyncHelper getInstance() {        if (instance == null) {            instance = new TemplateDirectorySyncHelper();            instance.initialize();        }        return instance;    }    private void initialize() {        Preferences tPreferences = Preferences.getInstance();        syncTemplatesEnabled = tPreferences.isAutoSyncTemplatesEnabled();        syncParserAssociationsEnabled = tPreferences.isAutoSyncParserAssociations();        teamTemplatesDirectoryName = tPreferences.getTeamTemplatesDirectory();    }    public void setSyncDirectoryPath(String syncDirectoryPath) {        TemplateDirectorySyncHelper.teamTemplatesDirectoryName = syncDirectoryPath;    }    public void enableSyncTemplates() {        TemplateDirectorySyncHelper.syncTemplatesEnabled = true;    }    public void disableSyncTemplates() {        TemplateDirectorySyncHelper.syncTemplatesEnabled = false;    }    public void enableSyncParserAssociations() {        TemplateDirectorySyncHelper.syncParserAssociationsEnabled = true;    }    public void disableSyncParserAssociations() {        TemplateDirectorySyncHelper.syncParserAssociationsEnabled = false;    }    public void syncLocalTemplates() {        Date tDate1 = Preferences.getInstance().getLastSyncDate();        Date tDate2 = Calendar.getInstance().getTime();        if (tDate1 == null || DateUtil.getTimeDifference(tDate1, tDate2) > SYNC_INTERVAL_IN_HOURS) {            syncLocalTemplatesImmediately();        }    }    public void syncLocalTemplatesImmediately() {        if (!syncTemplatesEnabled) {            return;        }        Preferences tPreferences = Preferences.getInstance();        String tLocalTemplatesDirectoryName = null;        try {            tLocalTemplatesDirectoryName = tPreferences.getTemplatesDirectory();            if (tLocalTemplatesDirectoryName != null && !new File(tLocalTemplatesDirectoryName).exists()) {                PluginLogger.logger.warning("Template directory does not exist");            }        } catch (Throwable e) {            PluginLogger.logger.warning(StackTraceUtil.getStackTrace(e));        }        if (tLocalTemplatesDirectoryName == null) {            PluginLogger.logger.warning("No template directory set");            return;        }        try {            if (teamTemplatesDirectoryName != null && !new File(teamTemplatesDirectoryName).exists()) {                PluginLogger.logger.warning("Sync template directory does not exist");            }        } catch (Throwable e) {            PluginLogger.logger.warning(StackTraceUtil.getStackTrace(e));        }        if (teamTemplatesDirectoryName == null) {            PluginLogger.logger.warning("No sync template directory set");            return;        }        // Sync the files in the sync directory down to the local directory        // replacing any with the same name that exists but do not disturb        // any files that were created in the local directory that are not        // found in the sync directory.        File tLocalTemplateDirectory = new File(tLocalTemplatesDirectoryName);        File tTeamTemplatesDirectory = new File(teamTemplatesDirectoryName);        if (!tLocalTemplateDirectory.exists()) {            PluginLogger.logger.warning("Local template directory does not exist.");            return;        }        if (!tLocalTemplateDirectory.isDirectory()) {            PluginLogger.logger.warning("Local template path is not a directory.");            return;        }        try {            boolean tIsSmartSync = tPreferences.isSmartSyncEnabled();            synchronize(tTeamTemplatesDirectory, tLocalTemplateDirectory, tIsSmartSync);            if (syncParserAssociationsEnabled) {                loadParserAssociations();            }            tPreferences.setLastSyncDate(Calendar.getInstance().getTime());        } catch (Throwable e) {            PluginLogger.logger.severe("Synchronization failed.");            PluginLogger.logger.severe(StackTraceUtil.getStackTrace(e));        }        return;    }    private void synchronize(File source, File destination, boolean aIsSmartSync) throws IOException {        synchronize(source, destination, aIsSmartSync, DEFAULT_COPY_BUFFER_SIZE);    }    private void synchronize(File source, File destination, boolean aIsSmartSync, long chunkSize) throws IOException {        if (chunkSize <= 0) {            System.out.println("Chunk size must be positive: using default value.");            chunkSize = DEFAULT_COPY_BUFFER_SIZE;        }        if (!source.exists()) {            throw new FileNotFoundException("Team template directory not found:" + source);        }        if (source.isDirectory()) {            if (!destination.exists()) {                if (!destination.mkdirs()) {                    throw new IOException("Could not create path " + destination);                }            } else if (!destination.isDirectory()) {                throw new IOException("Source and Destination not of the same type:" + source.getCanonicalPath() + " , "                    + destination.getCanonicalPath());            }            String[] tSources = source.list();            // copy each file from source            for (String tFileName : tSources) {                File tSrcFile = new File(source, tFileName);                File tDestFile = new File(destination, tFileName);                synchronize(tSrcFile, tDestFile, aIsSmartSync, chunkSize);            }        } else {            if (destination.exists() && destination.isDirectory()) {                deleteFileOrDirectory(destination);            }            if (destination.exists()) {                // do not copy if smart and same timestamp and same length                if (!aIsSmartSync || !areInSync(source, destination)) {                    copyFile(source, destination, chunkSize);                }            } else {                copyFile(source, destination, chunkSize);            }        }    }    private boolean areInSync(File source, File destination) throws IOException {        long tSts = source.lastModified() / FAT_PRECISION;        long tDts = destination.lastModified() / FAT_PRECISION;        if (tSts == 0 || tSts != tDts || source.length() != destination.length()) {            return false;        }        return true;    }    private void copyFile(File srcFile, File destFile, long chunkSize) throws IOException {        FileInputStream tInputStream = null;        FileOutputStream tOutputStream = null;        try {            tInputStream = new FileInputStream(srcFile);            FileChannel tInputChannel = tInputStream.getChannel();            tOutputStream = new FileOutputStream(destFile, false);            FileChannel tOutputChannel = tOutputStream.getChannel();            long tDoneBytes = 0L;            long tTodoBytes = srcFile.length();            while (tTodoBytes != 0L) {                long tIterationBytes = Math.min(tTodoBytes, chunkSize);                long tTransferredLength = tOutputChannel.transferFrom(tInputChannel, tDoneBytes, tIterationBytes);                if (tIterationBytes != tTransferredLength) {                    throw new IOException("Error during file transfer: expected " + tIterationBytes + " bytes, only " + tTransferredLength                        + " bytes copied.");                }                tDoneBytes += tTransferredLength;                tTodoBytes -= tTransferredLength;            }        } catch (Throwable e) {            PluginLogger.logger.severe("Synchronization of file '" + destFile.getAbsolutePath() + "' failed.");            PluginLogger.logger.severe(StackTraceUtil.getStackTrace(e));        } finally {            if (tInputStream != null) {                tInputStream.close();            }            if (tOutputStream != null) {                tOutputStream.close();            }        }        boolean tSuccessTimestampOp = destFile.setLastModified(srcFile.lastModified());        if (!tSuccessTimestampOp) {            PluginLogger.logger.warning("Could not change timestamp for {}. Index synchronization may be slow. " + destFile);        }    }    private void deleteFileOrDirectory(File file) {        if (file.isDirectory()) {            for (File tSubFile : file.listFiles()) {                deleteFileOrDirectory(tSubFile);            }        }        if (file.exists()) {            if (!file.delete()) {                PluginLogger.logger.severe("Could not delete {}" + file);            }        }    }    private void loadParserAssociations() throws Exception {        Properties tParserAssociations = new Properties();        File tFile = new File(Preferences.getInstance().getParserAssociations());        if (!tFile.exists()) {            PluginLogger.logger.warning("File with parser associations not found: " + tFile.getCanonicalPath());            return;        }        tParserAssociations.load(new FileInputStream(tFile));        Preferences.getInstance().setParserAssociations(tParserAssociations);    }}